<!DOCTYPE html>
<html>
<head>
<title>Documentation.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="easy-state-documentation">Easy State Documentation</h1>
<p><img src="images/IconTest.png" alt="Easy State Icon"></p>
<hr>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#easy-state-documentation">Easy State Documentation</a>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#lexicon">Lexicon</a>
<ul>
<li><a href="#core-components">Core Components</a>
<ul>
<li><a href="#datatype"><code>DataType</code></a></li>
<li><a href="#action"><code>Action</code></a></li>
<li><a href="#parameterized-action"><code>Parameterized Action</code></a></li>
<li><a href="#condition"><code>Condition</code></a></li>
<li><a href="#evaluator"><code>Evaluator</code></a></li>
</ul>
</li>
<li><a href="#designer-terms">Designer Terms</a>
<ul>
<li><a href="#designer"><code>Designer</code></a></li>
<li><a href="#design"><code>Design</code></a></li>
<li><a href="#node"><code>Node</code></a></li>
<li><a href="#connection"><code>Connection</code></a></li>
<li><a href="#update-cycle"><code>Update Cycle</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-editing">1. Editing</a>
<ul>
<li><a href="#11-creating-core-components">1.1 Creating Core Components</a>
<ul>
<li><a href="#create-components-via-asset-menu">Create Components via Asset Menu</a></li>
<li><a href="#create-components-inside-data-data-type">Create Components Inside Data Data Type</a></li>
<li><a href="#inheritance">Inheritance</a></li>
<li><a href="#how-to-create-components-from-scratch">How to Create Components from Scratch</a></li>
<li><a href="#tips">Tips</a></li>
</ul>
</li>
<li><a href="#12-designer">1.2 Designer</a>
<ul>
<li><a href="#controls">Controls</a></li>
<li><a href="#getting-started">Getting Started</a></li>
<li><a href="#nodes">Nodes</a>
<ul>
<li><a href="#node-settings-foldout">Node Settings Foldout</a></li>
<li><a href="#node-description-foldout">Node Description Foldout</a></li>
<li><a href="#actions-foldout">Actions Foldout</a></li>
<li><a href="#connections-foldout">Connections Foldout</a></li>
<li><a href="#summary-foldout">Summary Foldout</a></li>
</ul>
</li>
<li><a href="#connections">Connections</a></li>
<li><a href="#groups">Groups</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#jumper-node">Jumper Node</a></li>
<li><a href="#designs-vs-behaviors">Designs vs Behaviors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-in-unity">2. In Unity</a>
<ul>
<li><a href="#21-easy-state-machine">2.1 Easy State Machine</a>
<ul>
<li><a href="#settings">Settings</a></li>
<li><a href="#easy-state-machine-component-in-play-mode">Easy State Machine Component in Play Mode</a></li>
</ul>
</li>
<li><a href="#22-event-handlers">2.2 Event Handlers</a></li>
<li><a href="#23-easy-refresher">2.3 Easy Refresher</a></li>
<li><a href="#24-debugger-window">2.4 Debugger Window</a>
<ul>
<li><a href="#format-data-popups">Format Data Popups</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-misc">3. Misc</a>
<ul>
<li><a href="#31-settings">3.1 Settings</a></li>
<li><a href="#32-data">3.2 Data</a></li>
<li><a href="#33-easy-state-v3-vs-easy-state-v2">3.3 Easy State v3 vs Easy State v2</a></li>
<li><a href="#34-faq">3.4 FAQ</a>
<ul>
<li><a href="#newtonsoft-not-found">Newtonsoft not found?</a></li>
<li><a href="#unexpected-datatype-function-behavior">Unexpected DataType function behavior?</a></li>
<li><a href="#how-should-i-work-with-easy-state-machine-data">How should I work with Easy State Machine data?</a></li>
<li><a href="#how-should-i-use-the-single-event-handler">How should I use the Single Event Handler?</a></li>
<li><a href="#how-can-i-get-a-reference-to-the-state-machines-data-instance-in-unity">How can I get a reference to the state machine's data instance in Unity?</a></li>
</ul>
</li>
<li><a href="#35-built-in-components">3.5 Built In Components</a>
<ul>
<li><a href="#always-true-condition">Always True Condition</a></li>
<li><a href="#log-message-action">Log Message Action</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-tutorials">4. Tutorials</a>
<ul>
<li><a href="#general-workflow-overview">General Workflow Overview</a></li>
<li><a href="#create-your-first-state-machine">Create Your First State Machine</a>
<ul>
<li><a href="#steps">Steps</a></li>
</ul>
</li>
<li><a href="#patrol-tutorial">Patrol Tutorial</a>
<ul>
<li><a href="#steps-1">Steps</a></li>
</ul>
</li>
<li><a href="#where-to-go-from-here">Where to Go from Here</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="introduction">Introduction</h2>
<p>Easy State at its core is a programmer centric visual state machine editor. It tries to take care of all the repetitive code that comes with handling state machines but allow the programmer the most flexibility possible. As such, Easy State is more than a strict state machine as it also allows behavior tree like designs as well as utility based nodes. With the 3rd version of this tool Easy State has gotten an upgrade incorporating many quality of life changes and user suggested features yielding the most powerful flexible Easy State version yet. To get a quick overview jump to the <a href="#general-workflow-overview">General Workflow Overview</a> section.</p>
<h2 id="lexicon">Lexicon</h2>
<p>Here is a list of common words and their meanings in the EasyState universe.</p>
<h3 id="core-components">Core Components</h3>
<p><img src="images/DataTypeStructure.png" alt="Data Type"></p>
<h4 id="datatype"><code>DataType</code></h4>
<p>In essence a data type is just a data container. Think of it like a blue print for your state machine. The way Easy State is designed each state machine is strongly typed by the <code>DataType</code> you create. If that doesn't make sense right now don't worry, it will later. All data types inherit from <code>DataTypeBase</code>. <code>DataTypeBase</code> comes with a couple fields that are of interest.</p>
<ul>
<li>DataGrabBag
A generic data container used for passing raw data into and out of the state machine.</li>
<li>FSM_GameObject
GameObject that this state machine is attached to.</li>
<li>FSM_Transform
Transform that this state machine is attached to.</li>
</ul>
<blockquote>
<p>Data Type support inheritance. Meaning that actions/conditions/evaluators that you define on a base class will be available for sub classes.</p>
</blockquote>
<p>When you create a data type the will be an additional field added to the template of type <code>DataTypeFunctionSet</code> this field can be renamed and is used to define Actions,Conditions and Evaluators in line instead of in a separate file. More on this later.</p>
<h4 id="action"><code>Action</code></h4>
<p>This defines what your state machine does. If your state machine needs to increment a score or tick a timer it should be done inside of an <code>Action</code>.</p>
<h4 id="parameterized-action"><code>Parameterized Action</code></h4>
<p>Parameterized Actions inherit from <code>Action</code>. They add the ability to pass a primitive argument straight from the design to an action. In order to use them create a 'Parameterized Action' from the Asset Menu. Then replace the placeholder 'TParameterType' with your desired parameter type. Currently supports int, float, string, and boolean parameter types.</p>
<h4 id="condition"><code>Condition</code></h4>
<p>Conditions dictate the flow of your state machine. They are boolean and therefore always evaluate as true or false.</p>
<h4 id="evaluator"><code>Evaluator</code></h4>
<p>Evaluators are used when you would rather score a transition instead of returning a simple true or false. This can be useful when trying to decide between more than two possibilities.</p>
<blockquote>
<p>Note: DataTypes, Actions, Conditions, and Evaluators that are file based can be renamed. Their <code>EasyStateScript</code> attributes must not be altered. Inline components can also be renamed, but any references that exist to those components inside a design will be lost.</p>
</blockquote>
<hr>
<h3 id="designer-terms">Designer Terms</h3>
<hr>
<h4 id="designer"><code>Designer</code></h4>
<p>The Designer is an Unity Editor window that you will use to create and edit designs.</p>
<h4 id="design"><code>Design</code></h4>
<p>Designs are created in the Designer. A design defines a graph of nodes and connections that can be translated into a behavior to be consumed in Unity if the design is valid.</p>
<h4 id="node"><code>Node</code></h4>
<p>A node or state references a point in the design graph where actions can be executed or update cycles delayed before traversing to the next node.</p>
<h4 id="connection"><code>Connection</code></h4>
<p>Connects two states or nodes together. There are two types of connections.</p>
<ul>
<li>Conditional Connections
Rely on <code>Condition</code> types as defined in the above core component section to decided whether or not the connection can be traversed.</li>
<li>Evaluator Connections
Rely on <code>Evaluator</code> types as defined in the above core component section. Each connection returns a score. The connection with the highest score is selected to be traversed.</li>
</ul>
<h4 id="update-cycle"><code>Update Cycle</code></h4>
<p>Refers to when a state machine is told to update. Typically the first time a state machine is told to update it will start by updating the entry node(first node of the design) and continuing to update nodes until it updates a node that has a cycle type that is not <code>Pass Through</code>(<a href="#node-settings-foldout">more on this</a>) or a node that is a leaf node. Leaf nodes automatically loop back to the entry node after being updated.</p>
<hr>
<h2 id="1-editing">1. Editing</h2>
<hr>
<p>This section covers how to create components and use them inside the designer.</p>
<h3 id="11-creating-core-components">1.1 Creating Core Components</h3>
<hr>
<h4 id="create-components-via-asset-menu">Create Components via Asset Menu</h4>
<p>Start off by creating a Data Type. To do this you can either open the Assets Menu and navigate to EasyState/New Data Type or alternatively right clicking in the Unity's Project window and navigating to EasyState/New Data Type.</p>
<p><img src="images/create-new-dataType.png" alt="Create New Data Type"></p>
<p>When you click on the New Data Type button you will be presented with a File Explorer popup to allow you to select where you want to save the new Data Type file. Once a location has been selected Easy State will generate two files.</p>
<ul>
<li>{Data Type Name}.cs
This is the actual data type file that you can edit to add all the fields you want to expose to your state machines.</li>
<li>{Data Type Name}.asset
This is a ScriptableObject instance of your data type. This is used by the Easy State Machine component in your Unity Scene.</li>
<li>{Data Type Name}StateMachine.cs
This is the State Machine component you will use to utilize any designs you create that use this data type. It is a Unity component and can be added to gameObjects.</li>
</ul>
<p>Once created the new Data Type will be added to the Easy State Assets menu list. In the image above we have created a Data Type called <code>TestData</code>.
You will notice this menu allows you to create Actions, Parameterized Actions, Conditions, and Evaluators for particular Data Types.</p>
<p><img src="images/create-new-action.png" alt="Create New Data Type"></p>
<blockquote>
<p>Note: Easy State scans Unity's Assemblies for newly added core components. As such you can rename or delete generated scripts as you please but you should not edit the <code>[EasyStateScript]</code> attribute, as this is how the framework keeps track of which components have been added/moved/or deleted. Additionally be aware that deleting components can invalidate designs and thereby delete their associated behaviors that may be being used by Easy State Machine components in your Unity Scene.</p>
</blockquote>
<h4 id="create-components-inside-data-data-type">Create Components Inside Data Data Type</h4>
<p>You can add components to a data type by adding components directly to the <code>DataTypeFunctionSet</code> inside of the Data Type file inside the constructor. There are several key methods to add functions or component to a Data Type's set.</p>
<p><code>Actions</code>
You can add actions to the set by utilizing the <code>AddAction</code> method. This method requires an <code>Action&lt;T&gt;</code> where <code>T</code> is the Data Type and a unique name for the action.</p>
<p><img src="images/add-action.png" alt="Add action to data type"></p>
<p>There is also an <code>AddLoggingAction</code> method that makes it easy to create logging actions for diagnostic purposes.</p>
<p><code>Conditions</code>
There are multiple ways to add conditions to a set. If a field or property is of type <code>bool</code> it will be automatically added to the function set and will be able to be used in the designer.</p>
<p><img src="images/add-implicit-condition.png" alt="Add implicit conditions to data type"></p>
<p>You can also define a conditional function using the <code>AddCondition</code></p>
<p><img src="images/add-conditional-function.png" alt="Add conditional function to data type"></p>
<p>Or use a fluent API approach:</p>
<p><img src="images/add-conditional-fluent-api.png" alt="Add conditional function to data type with fluent API"></p>
<p>There are a few fluent API methods available to make simple comparison fast and easy to read.</p>
<p><code>Evaluator</code>
Evaluators can be added by using the <code>AddEvaluator</code> method. This method requires a <code>Func&lt;T,float&gt;</code> where <code>T</code> is the Data Type being used and the float that is returned is the score your evaluator yields. This method also requires a unique evaluator name.</p>
<p><img src="images/add-evaluator.png" alt="Add conditional function to data type with fluent API"></p>
<h4 id="inheritance">Inheritance</h4>
<p>Inheritance is supported! This means that if you inherit from a Data type that you created, all the actions, conditions, and evaluators will be able to be used from the parent data type in the designer.</p>
<h4 id="how-to-create-components-from-scratch">How to Create Components from Scratch</h4>
<p>The first few steps are identical for all Easy State components.</p>
<ol>
<li>
<p>Create a C# script in Unity(Create/C# Script) and delete the placeholder methods.</p>
</li>
<li>
<p>Add a <code>using EasyState.Models</code></p>
</li>
<li>
<p>Add the attribute:<code>[EasyStateScript(&quot;some-unique-string-value&quot;)]</code> to the class.</p>
</li>
<li>
<p>Update the class's subtype:</p>
<ul>
<li>Data Types inherit from <code>DataTypeBase</code></li>
<li>Actions inherit from <code>Action&lt;YourDataType&gt;</code></li>
<li>Conditions inherit from <code>Condition&lt;YourDataType</code></li>
<li>Evaluators inherit from <code>Evaluator&lt;YourDataType&gt;</code></li>
</ul>
</li>
</ol>
<h4 id="tips">Tips</h4>
<ul>
<li>If you want to add or change default using statements in any of these templates, their text files can be found at Assets/EasyState/Editor/Templates</li>
<li>Generated components like Actions or Conditions should be stateless. All the state should be contained in the Data Type object.</li>
<li>You can rename set fields in Data Types to any name you'd like.</li>
<li>Take care when naming components as clear and precise names will make your life easier inside the designer.</li>
</ul>
<h3 id="12-designer">1.2 Designer</h3>
<hr>
<p><img src="images/designLocation.png" alt="Designer Tab"></p>
<p>The window can be found under the 'Window/EasyState/Editor' tab at the top of Unity.The window is a draggable/dockable and behaves in the same way as other Unity windows like 'Scene' and 'Game' work.</p>
<h4 id="controls">Controls</h4>
<p><em>Pan</em> : Ctrl + Left Mouse or Middle Mouse Button
<em>Zoom</em>: Mouse wheel
<em>Select</em>: Left Mouse
<em>Multi-Select</em> Left Click Background + Drag OR Ctrl + Left Click
<em>Open Element Details</em> : Double Left Click
<em>Drag Element</em> : Left Click Element + Drag
<em>Save</em> : Ctrl + S
<em>Context Menu</em> : Right Click
<em>Delete Element</em> : Del
<em>Duplicate Element</em> : Ctrl + D
<em>Rebuild Editor</em> : Ctrl + R
<em>Validate Design</em> : Ctrl + V
<em>Group Nodes</em> : Ctrl + G</p>
<h4 id="getting-started">Getting Started</h4>
<p>When first opening the designer you will be greeted with a loader panel that allows you to manage your designs. Assuming you have created a Data Type already it should look something like this :</p>
<p><img src="images/design-loader.png" alt="Designer Loader Panel"></p>
<p>Once a design has been created your design will start off with an Entry Node already created. Entry nodes act as the starting point of all designs.</p>
<p><img src="images/new-design.png" alt="New Design Tab"></p>
<p>With the new design open you can start adding nodes by right clicking on the designer background and picking the node preset you want.</p>
<h4 id="nodes">Nodes</h4>
<p>When you right click the background of the designer you are greeted with a context menu that has by default six options.</p>
<p><img src="images/context-menu.png" alt="Context Menu"></p>
<p>The top 4 options are all just different node presets(More on these later). While the bottom two represent different node types completely. If we create a state node and double click on it, it will open the detail panel for the node.</p>
<p><img src="images/node-details-panel.png" alt="Node details"></p>
<h5 id="node-settings-foldout">Node Settings Foldout</h5>
<p>When the settings foldout is expanded you will see that nodes have three dropdowns that greatly alter the behavior of the node.</p>
<p><img src="images/node-settings-expanded.png" alt="Node settings"></p>
<ul>
<li>
<p>Condition Type
This controls what types of exit connections this node will make.</p>
<ul>
<li>
<p>Default(<a href="#connection">Conditional Connections</a>)
Can have one <code>AlwaysTrue</code> connection to another node. If there are more than a single connection or the single connection is not an <code>AlwaysTrue</code> connection than a fallback connection must be defined. Which can be seen below as the &quot;Else go to&quot; connection.</p>
<p><img src="images/node-with-fallback.png" alt="Node settings"></p>
</li>
<li>
<p>Repeat(<a href="#connection">Conditional Connections</a>)
Must have one or more connections, but has no fallback connection. Connections are evaluated from top to bottom and if no connections are picked then the state machine stays in the same state. It will then re-evaluate the connections from top to bottom on the next <a href="#update-cycle">update cycle</a>.</p>
</li>
<li>
<p>Utility(<a href="#connection">Evaluator Connections</a>)
Must have one or more connections and all connections will be evaluators instead of conditional.</p>
</li>
</ul>
</li>
<li>
<p>Action Execution</p>
<ul>
<li>Default
Actions will always execute from top to bottom based on their associated phase. So if a phase is set to &quot;On Enter&quot; the action will always execute when the state is entered.</li>
<li>Conditional Execution
This allows controlling execution of an action based on a condition. As in the case below &quot;Log Age&quot; will only be executed when &quot;IsEnabled&quot; is true.</li>
</ul>
<p><img src="images/conditional-action.png" alt="Conditional actions"></p>
</li>
<li>
<p>Cycle Type</p>
<ul>
<li>Pass Through
A node with cycle type set to pass through will not cause the <a href="#update-cycle">update cycle</a> to pause. Instead the state machine will update that node and immediately transition into the next node. Except if the node in question is a leaf node(has no exit connections). In which case it will mark the end of an update cycle before the state machine loops back to the entry state node.</li>
<li>Yield Cycle
A node with yield cycle marks the end of an update cycle for a state machine. By default &quot;Repeater&quot; node preset is set to Yield Cycle. This is a good way of adding &quot;steps&quot; into your state machine. Refer to the sample title &quot;First Beer&quot; in Assorted examples to see this node type in action.</li>
<li>Yield Seconds
Just like it sounds if a node has this cycle type it will yield a delay in seconds upon exiting and before entering the next state.</li>
<li>Yield Variable Delay
This is like Yield Seconds but allows you to bind the delay amount to a float variable in the data type the design is using. Therefore giving you the ability to set the delay amount at runtime.</li>
</ul>
</li>
</ul>
<h5 id="node-description-foldout">Node Description Foldout</h5>
<p>All of the above can be a lot to keep straight in your head. That is why each node has a dynamic node description that updates based on its settings to tell you how a particular node will behave.</p>
<p><img src="images/node-description.png" alt="Node description"></p>
<h5 id="actions-foldout">Actions Foldout</h5>
<p>A list of all actions that will be executed in this node. Display will change based on the Action Execution Type in the settings foldout.</p>
<h5 id="connections-foldout">Connections Foldout</h5>
<p>A list of exit connections for the selected node. You can add/remove and set the destinations of the connections from this foldout.</p>
<h5 id="summary-foldout">Summary Foldout</h5>
<p>Use the summary foldout to describe what a particular node is doing in your own words as an alternative to creating a Note node. This note will also be visible on the node itself if you expand the node's foldout.</p>
<h4 id="connections">Connections</h4>
<p>Double click on the triangle handle of a connection to open up its details panel.</p>
<p><img src="images/connection-details.png" alt="Connection Details"></p>
<p>As visible from the details panel above you can make a conditional expression of almost arbitrary complexity. To add a connection right click on a node or click on the split icon inside the nodes. To delete a node you can either delete it from the Node/Connections foldout or right clicking on the connection handle or pressing &quot;del&quot; when the connection is selected.</p>
<h4 id="groups">Groups</h4>
<p>Create a group by selecting more than one node or note and either hitting Ctrl+G or right clicking on a node and selecting &quot;Group Selected&quot;. Change the group name by double clicking on the group name in the editor. Nodes and notes can be grouped.</p>
<p><img src="images/group.png" alt="Group"></p>
<h4 id="notes">Notes</h4>
<p><img src="images/note.png" alt="Note"></p>
<h4 id="jumper-node">Jumper Node</h4>
<p><img src="images/jumper.png" alt="Jumper Node"></p>
<p>This node allows you to transition from one design to another.</p>
<h4 id="designs-vs-behaviors">Designs vs Behaviors</h4>
<p>A design is a Behavior in progress. The Unity State Machine components can only use Behaviors. Think of Behaviors as validated designs. When working on a design if it is valid, when you save changes to the design you will get a toast in the bottom right of the screen that indicates that a behavior was created or updated. This is a signal that everything in your design is valid. If you want to find out why your design is invalid either click the hamburger button menu at the right of the toolbar or use the shortcut key Ctrl + V to validate your design and see what is missing.</p>
<p><img src="images/workflow-save.png" alt="Save Design"></p>
<hr>
<h2 id="2-in-unity">2. In Unity</h2>
<hr>
<p>There are two main types of Unity MonoBehaviors that you will be using to interface between Unity and Easy State. The first one is the State Machine component which was created when you first created your Data Type. The second is an optional EventHandler that responds to all of the events generated by the State Machine. You will use this as an alternative to subscribing to events individually on the state machine component itself.</p>
<h3 id="21-easy-state-machine">2.1 Easy State Machine</h3>
<p>Assuming that you have a valid Design that has been converted into a Behavior the Easy State Machine component will look something like this:</p>
<p><img src="images/easy-state-machine.png" alt="Easy State Machine Component"></p>
<blockquote>
<p>Note: <code>DataTypeBase</code> the class all Data Types inherit from is itself a <code>ScriptableObject</code>. By default when loading up Easy State, it creates a clone of the Data Type so each state machine is using data for its own instance. This can be changed in the Settings foldout under the &quot;Use instance data&quot; check box. If this setting is unchecked all state machines will use the same instance of the Data Type.</p>
</blockquote>
<h4 id="settings">Settings</h4>
<ul>
<li>
<p>Start On
Controls when your State Machine begins updating.</p>
</li>
<li>
<p>Update Rate
Controls how often/and in what way your state machine will be updated.</p>
</li>
<li>
<p>Log warnings
The Easy State machine generates warnings when it detects something is not right. These log messages can be silenced if desired.</p>
</li>
<li>
<p>Individual Events
This decides how you want to handle events generated by the state machine. By default it uses individual Unity Events that can subscribed to under the events foldout. If you would prefer to have a single class container handle all the events you can uncheck this option and create a event handler. This is made simple for you by a button that creates a script from a template and adds it to the gameObject.</p>
<p><img src="images/create-event-handler.png" alt="Event Handler"></p>
</li>
</ul>
<blockquote>
<p>Note: due to the way the Unity Editor works if trying to assign an event handler manually to a state machine, the event handler must first be on a gameObject in the scene before it can be assigned.</p>
</blockquote>
<h4 id="easy-state-machine-component-in-play-mode">Easy State Machine Component in Play Mode</h4>
<p>The Easy State Machine component looks slightly different when the Editor is in play mode.</p>
<p><img src="images/state-machine-play-mode.png" alt="The Easy State Machine in PlayMode"></p>
<h3 id="22-event-handlers">2.2 Event Handlers</h3>
<p>Whether you decide to create an Event Handler or subscribe to the Unity Events individually the events will be the same.</p>
<ul>
<li><code>OnInitialize(EasyStateMachine machine)</code>
Called once when the state machine is first loaded. A reference to the state machine is passed to the subscriber to make it easier for the subscriber to reference the data instance being used.</li>
<li><code>OnPreUpdate()</code>
Called every single time a state machine is just about to be updated. This event is especially useful to be thought of as a prep event, where you can prepare your data to be consumed by the State Machine</li>
<li><code>OnStateEntered(State stateBeingEntered)</code>
Called once when a new state is entered. A reference to the state being entered is passed to the subscriber.</li>
<li><code>OnStateUpdated(State stateBeingUpdated)</code>
Called every time a state has been updated. A reference of the state that was updated is passed to the subscriber</li>
<li><code>OnStateExited(State stateBeingExited)</code>
Called once when a state is being exited. A reference to the state being exited is passed to the subscriber.</li>
<li><code>OnExitDelayStarted(float delayAmount)</code>
This event is called after the OnStateExited event if the state being exited has an exit delay.</li>
<li><code>OnPostUpdate</code>
This event is called when an <a href="#update-cycle">update cycle</a> for a state machine is completed. This is a useful event to use to react to changes that have taken place inside the State machine, perhaps to apply the changes that it calculated.</li>
</ul>
<h3 id="23-easy-refresher">2.3 Easy Refresher</h3>
<p><img src="images/easyRefresher.png" alt="Easy Refresher component"></p>
<p>This component is a singleton object that will be created at runtime if one does not already exist in the scene. The picture above shows the component while in Play Mode. When in play mode it displays various stats about how many state machines it is updating. Part of a state machine's initialization process is to register itself with this component. Once registered the Easy Refresher component orchestrates all the scheduled updates for all the state machines in the scene. This has various benefits the main one being that instead of 2000 <code>MonoBehavior</code>'s update methods being invoked you have one <code>MonoBehavior</code> that handles the update.</p>
<h3 id="24-debugger-window">2.4 Debugger Window</h3>
<p>This window is pretty simple. Before entering play mode, select the state machine from the open scene that you want to debug. Then enter play mode.</p>
<blockquote>
<p>Note: while the debugger works at any refresh rate, it may be beneficial to slow down the update process by going to the state machine's inspector and underneath the settings foldout selecting a slower update rate so you have time to inspect the values and update paths.</p>
</blockquote>
<p><img src="images/debugger-window.png" alt="Debugger Window"></p>
<h4 id="format-data-popups">Format Data Popups</h4>
<p>To format the data popups seen above implement the <code>ICustomDataTypeFormatter</code> interface on your Data Type. Rich text is supported, <a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/StyledText.html">here</a> is a full list of rich text tags that can be used.</p>
<hr>
<h2 id="3-misc">3. Misc</h2>
<hr>
<h3 id="31-settings">3.1 Settings</h3>
<p>The settings asset can be found at EasyState/Resources/Settings.asset. Each setting has a tooltip explaining more about its uses.</p>
<p><img src="images/settings.png" alt="Easy Refresher component"></p>
<h3 id="32-data">3.2 Data</h3>
<p>By default data is stored in Assets/EasyStateData folder. This can be changed by updating the settings and changing the &quot;Easy State Data Folder&quot; setting to a new home. This is best changed before you start creating designs and data types. The steps to move the data folder are:</p>
<ul>
<li>Close designer if open.</li>
<li>Make sure no state machine is selected by an inspector.</li>
<li>Create destination folder</li>
<li>Copy all files from EasyStateData and paste them in the destination folder.</li>
<li>Copy the new folder path</li>
<li>update the &quot;Easy State Data Folder&quot; settings to the new folder path.</li>
</ul>
<h3 id="33-easy-state-v3-vs-easy-state-v2">3.3 Easy State v3 vs Easy State v2</h3>
<p>Easy State version 3 is incompatible with version 2. But the concepts translate. In version 3 several 3rd party dependencies have been removed and more Unity native features have been leveraged to create a better experience. Essentially, the entire asset was re-written from scratch and is now much more stable and maintainable. Here is a list of new features that are in version 3 that were missing in version 2</p>
<ul>
<li>Group Nodes</li>
<li>Have multiple designs open at once</li>
<li>Data Type inheritance supported</li>
<li>Better shortcut keys</li>
<li>Hierarchical/Horizontal state machines</li>
<li>Fine grain control of node behavior</li>
<li>Expandable node presets</li>
<li>Improved editor experience and performance</li>
<li>Add notes to designs</li>
<li>Many more configurable settings</li>
<li>Easy State scripts can now be moved around and the changes are tracked</li>
<li>Stabilized editor serialization</li>
<li>No more reflection at runtime</li>
<li>Custom icons for generated easy state scripts to make it easier to keep track of.</li>
<li>Define easy state components in a single line of code.</li>
<li>Data types can inherit from other custom data types</li>
<li>Composite conditional statements</li>
<li>Node descriptions to make it easier to understand what will happen in a node</li>
<li>Debugger can debug state machines in play mode</li>
<li>Format how data is displayed in the debugger</li>
</ul>
<h3 id="34-faq">3.4 FAQ</h3>
<h4 id="newtonsoft-not-found">Newtonsoft not found?</h4>
<p>In older versions of Unity Newtonsoft was not included by default. If you are getting errors about Newtonsoft not be found go to:</p>
<p>&quot;Assets/EasyState/Newtonsoft/Runtime/Newtonsoft.Json.dll&quot;</p>
<p>Check &quot;Include/Editor&quot; option and apply changes.</p>
<p>then go to:</p>
<p>&quot;Assets/EasyState/Newtonsoft/Runtime/AOT/Newtonsoft.Json.dll&quot;</p>
<p>Check whatever build platform your game is using.</p>
<h4 id="unexpected-datatype-function-behavior">Unexpected DataType function behavior?</h4>
<p>Datatype function require captured variables in lambda's to work. Here is an example of the <em>wrong</em> way to declare a function.</p>
<pre class="hljs"><code><div>TestDataType_Set.AddAction(data =&gt; _stateEntered = Time.time, <span class="hljs-string">"Enter State "</span>);
</div></code></pre>
<p>Notice how this function is not using the captured variable? It should instead be initialized like this:</p>
<pre class="hljs"><code><div>TestDataType_Set.AddAction(data =&gt; data._stateEntered = Time.time, <span class="hljs-string">"Enter State "</span>);
</div></code></pre>
<h4 id="how-should-i-work-with-easy-state-machine-data">How should I work with Easy State Machine data?</h4>
<p>Easy State Machine Data all inherit from <code>DataTypeBase</code> which inherits from <code>UnityEngine.ScriptableObject</code> as such, serialization of this data is trivial. You should use your data type to contain all the state for the state machine. I.E. your components (Actions,Conditions, etc) should not contain any state. Your conditions should read the state of your data, and your actions should mutate that state. You should use the <code>OnInitialize</code> event on the EasyStateMachineComponent to initialize your data type's state.</p>
<h4 id="how-should-i-use-the-single-event-handler">How should I use the Single Event Handler?</h4>
<p>Event Handlers should be used to react to changes in your state machine and apply these changes to your Unity Scene(i.e. trigger animations, destroy gameObjects etc). As of version 3.1, EventHandlers are now easy to use on a 1:1 or a 1:Many relationship to state machines. One thing to keep in mind with EventHandlers is that the EasyStateMachine component has a field named 'Event Handler'. This expects an object of type <code>EventHandler&lt;T&gt;</code>. Since Unity doesn't handle generics very well you must first add your event handler to a gameObject first and then use that gameObject as a reference for the 'Event Handler' field. Otherwise the connection will not work.</p>
<h4 id="how-can-i-get-a-reference-to-the-state-machines-data-instance-in-unity">How can I get a reference to the state machine's data instance in Unity?</h4>
<p>Simply get a reference to the state machine and call the <code>GetDataInstance</code> method. Please note that this will return the object as <code>DataTypeBase</code> so you will need to cast it to whatever data type you are using.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> stateMachine = GetComponent&lt;EasyStateMachine&gt;();
EasyState.Models.DataTypeBase data = stateMachine.GetDataInstance();
</div></code></pre>
<h3 id="35-built-in-components">3.5 Built In Components</h3>
<h4 id="always-true-condition">Always True Condition</h4>
<p>This is a <code>Condition</code> that can be used by all designs, it always returns true and is the default condition used by new connections.</p>
<h4 id="log-message-action">Log Message Action</h4>
<p>This is an parameterized <code>Action</code> that can be used by all designs and is useful for logging debug messages as you are testing out your designs.</p>
<hr>
<h2 id="4-tutorials">4. Tutorials</h2>
<hr>
<h3 id="general-workflow-overview">General Workflow Overview</h3>
<ol>
<li>
<p>Create a data type
As mentioned in the <a href="#11-creating-core-components">1.1 Creating Core Components</a> section, you can create a data type by right clicking in the Project pane</p>
<p><img src="images/create-new-dataType.png" alt="Create New Data Type"></p>
</li>
<li>
<p>Once that data type is created, open up the designer &quot;Window/Easy State/Designer&quot; and create a design using your new data type.</p>
<p><img src="images/workflow-new-design.png" alt="Create New Design"></p>
</li>
<li>
<p>Create your design and save it. Make sure you get a &quot;behavior created&quot; or &quot;behavior updated&quot; toast on save.</p>
<p><img src="images/workflow-save.png" alt="Save Design"></p>
</li>
<li>
<p>If you did not get the behavior confirmation message hit Ctrl+V to validate your design and see what the errors are.</p>
<p><img src="images/workflow-validate.png" alt="Validate Design"></p>
</li>
<li>
<p>Correct any errors and retry saving.</p>
</li>
<li>
<p>Create an empty gameObject in your scene and attach a {YourDataType}StateMachine component to that gameObject.</p>
<p><img src="images/workflow-component.png" alt="Create component"></p>
</li>
<li>
<p>Create a new data type asset or select an existing asset and set the &quot;Data&quot; field of the component.</p>
<p><img src="images/workflow-settings.png" alt="Create component"></p>
</li>
<li>
<p>Select an Update Rate</p>
</li>
<li>
<p>Click play and your state machine should be running!</p>
</li>
</ol>
<h3 id="create-your-first-state-machine">Create Your First State Machine</h3>
<p>We are going to create a state machine that logs &quot;Heads&quot; or &quot;Tails&quot; to the console randomly. This will help cement the ideas in the above workflow section.</p>
<h4 id="steps">Steps</h4>
<ol>
<li>
<p>Create a new folder in your Assets folder titled &quot;FirstDataType&quot;.</p>
</li>
<li>
<p>In that folder right click and select &quot;Create New Data Type&quot;</p>
<p><img src="images/create-new-dataType.png" alt="Create New Data Type"></p>
</li>
<li>
<p>Select your newly created folder as a destination and name the data type &quot;FirstDataType&quot;.</p>
<p><img src="images/fdt-dataType.png" alt="Create New Data Type"></p>
</li>
<li>
<p>Double click on the newly created data type to open it up in your script editor.</p>
</li>
<li>
<p>Let's add our random condition and two logging actions to our data type.</p>
<p><img src="images/fdt-script.png" alt="Data Type script"></p>
</li>
<li>
<p>Open up the designer, if the design loader isn't visible click the plus icon in the left column to open it up. In the &quot;Create New Design&quot; section, select &quot;FirstDataType&quot; as your Data Type and create a design named &quot;First Design&quot;.</p>
<p><img src="images/fdt-newdesign.png" alt="Create New Design"></p>
</li>
<li>
<p>Create the design, and add two state nodes to the design by right clicking the background and selecting &quot;Create State Node&quot;. Name one state &quot;Heads&quot; and the other &quot;Tails&quot;.</p>
<p><img src="images/fdt-design-1.png" alt="Create New Design"></p>
</li>
<li>
<p>Click the split icon on the entry node to create a connection, then click on the heads node to make the connection.</p>
</li>
<li>
<p>Double click on triangle handle in the new connection to bring up the connection details panel.</p>
</li>
<li>
<p>Select the random condition as the connection's condition.</p>
</li>
</ol>
<p><img src="images/fdt-design-2.png" alt="Create New Design"></p>
<ol start="11">
<li>Double click on the entry node to bring up its details panel and set the fallback connection to the &quot;Tails&quot; node.</li>
</ol>
<p><img src="images/fdt-design-3.png" alt="Create New Design"></p>
<ol start="12">
<li>Double click on the Heads node and expand its actions foldout. Add the action &quot;Log Heads&quot;.</li>
</ol>
<p><img src="images/fdt-design-4.png" alt="Create New Design"></p>
<ol start="13">
<li>Add the &quot;Log Tails&quot; action to the &quot;Tails&quot; node.</li>
<li>Hit Ctrl+S to save the design and make sure you receive the &quot;Behavior Created&quot; confirmation toast at the bottom right of the screen.</li>
</ol>
<p><img src="images/workflow-save.png" alt="Save Design"></p>
<ol start="15">
<li>If you did not see this confirmation, hit Ctrl+V to validate your design and fix whatever errors are present. Then try saving again.</li>
<li>Create a new gameObject and add a FirstDataTypeStateMachine component to it.</li>
<li>Create a new Data Type asset by clicking the &quot;Create New&quot; button and saving it into your &quot;FirstDataType&quot; folder.</li>
<li>Set the &quot;Data&quot; reference to the newly created Data Type asset.</li>
<li>Enter play mode. With your new gameObject selected click the &quot;Update&quot; button on the state machine component to update it. It should be looking something like this :</li>
</ol>
<p><img src="images/fdt-gb.png" alt="First Data type component"></p>
<ol start="20">
<li>Check the console! You should be getting messages!</li>
</ol>
<p><img src="images/fdt-console.png" alt="First Data type component"></p>
<h3 id="patrol-tutorial">Patrol Tutorial</h3>
<p>Let's set up a simple scene with an agent that patrols through a set of waypoints. If you haven't done the 'First State Machine' tutorial yet it is recommended that you do that first to get a little more familiar with the interface. This demo can be found completed under EasyState/Samples/Patrol</p>
<h4 id="steps">Steps</h4>
<ol>
<li>
<p>Set up a scene in Unity with a floor, some obstacles, and a cylinder to represent an agent.
<img src="images/patrol-setup.png" alt="Set up"></p>
</li>
<li>
<p>Add a series of way points for your agent to traverse, for example:
<img src="images/patrol-waypoints.png" alt="Waypoints"></p>
</li>
<li>
<p>Create a DataType called <code>PatrolData</code> with the following fields:</p>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> Transform[] Waypoints;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Speed;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> _currentIndex;
</div></code></pre>
<ol start="4">
<li>Define a condition to check to see if we have reached a waypoint:</li>
</ol>
<pre class="hljs"><code><div>
   PatrolData_Set.AddCondition(data =&gt; Vector3.Distance(data.FSM_Transform.position, data.Waypoints[data._currentIndex].position) &lt; <span class="hljs-number">.1</span>f, <span class="hljs-string">"Has Reached Target"</span>);
</div></code></pre>
<ol start="5">
<li>Define an action to move the agent towards the current waypoint:</li>
</ol>
<pre class="hljs"><code><div>
   PatrolData_Set.AddAction(data =&gt;
        {
            <span class="hljs-keyword">var</span> nextMove = Vector3.MoveTowards(data.FSM_Transform.position,data.Waypoints[data._currentIndex].position, data.Speed * Time.deltaTime);
            FSM_Transform.position = nextMove;
            FSM_Transform.LookAt(data.Waypoints[data._currentIndex]);
        }
</div></code></pre>
<ol start="6">
<li>Define an action to increment the current way point:</li>
</ol>
<pre class="hljs"><code><div>PatrolData_Set.AddAction(data =&gt; data._currentIndex = (_currentIndex + <span class="hljs-number">1</span>) % data.Waypoints.Length, <span class="hljs-string">"Pick Next Point"</span>);
</div></code></pre>
<ol start="7">
<li>Create a new Design with the <code>PatrolData</code> data type named 'Patrol'.</li>
<li>Add a Repeater Node and a State node to the design. Then connect them like the picture below:</li>
</ol>
<p><img src="images/patrol-design.png" alt="Design"></p>
<ol start="9">
<li>Double click on the connection handle between 'Move' and 'Pick New Point' and select 'Has Reached Target' is true.</li>
</ol>
<p><img src="images/patrol-connection.png" alt="Connection"></p>
<ol start="10">
<li>Double click on the 'Move' node and add the 'Move Towards Target' action to the node.</li>
<li>Double click on the 'Pick New Point' node and add the 'Pick Next Point' action to the node.</li>
<li>Under Pick Next Point's setting foldout set the Cycle type to 'Yield Seconds' and set the Exit Delay value to something reasonable</li>
</ol>
<p><img src="images/patrol-node-settings.png" alt="Node Settings"></p>
<ol start="13">
<li>Hit Ctrl+S to save the design and make sure you see a confirmation in the bottom right of the screen that says the design and behavior were saved.</li>
</ol>
<p><img src="images/patrol-design-saved.png" alt="Save Design"></p>
<ol start="14">
<li>In the Unity Scene add a <code>PatrolDataStateMachine</code> component to your agent, click the 'Create New'  button on the data type field and add a reference to the newly created asset.</li>
</ol>
<p><img src="images/patrol-new-data-asset.png" alt="New Data Type asset"></p>
<ol start="15">
<li>Set the speed variable to something reasonable.</li>
<li>Under the settings foldout set the Update Rate to 'Update'</li>
<li>Open the <code>PatrolDataStateMachine</code> script and add the following method:</li>
</ol>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateMachineInitialized</span>(<span class="hljs-params">EasyStateMachine stateMachine</span>)</span>
    {
        <span class="hljs-keyword">var</span> data  = stateMachine.GetDataInstance() <span class="hljs-keyword">as</span> PatrolData;

        <span class="hljs-keyword">var</span> transformsParent = GameObject.Find(<span class="hljs-string">"Waypoints"</span>);
        <span class="hljs-comment">//skip the parent transform</span>
        <span class="hljs-keyword">var</span> transforms = transformsParent.GetComponentsInChildren&lt;Transform&gt;().Skip(<span class="hljs-number">1</span>).ToArray();
        <span class="hljs-comment">//set the Waypoints field</span>
        data.Waypoints = transforms;
    }
</div></code></pre>
<ol start="18">
<li>Under the Events foldout on the <code>PatrolDataStateMachine</code> component hook the method you just created to the OnInitialize event.</li>
</ol>
<p><img src="images/patrol-event.png" alt="State Machine event"></p>
<ol start="19">
<li>Click play and your agent should be moving along the set of waypoints you created!</li>
</ol>
<h3 id="where-to-go-from-here">Where to Go from Here</h3>
<p>Congratulations on your first operating state machine. From here you can fiddle around with various settings like refresh type. Maybe use the event handler to respond to different points in the <a href="#update-cycle">update cycle</a>. In the Samples folder there is a Unity package that can be imported into a fresh project. This sample includes this state machine you just made as well as several others showcasing various aspects of Easy State functionality.There will be some video tutorials posted on <a href="https://www.youtube.com/channel/UCqpzOtqr6FiJ6LOBzW5sJSQ">YouTube</a> where you can find a video version of the above tutorial and more.</p>
<blockquote>
<p>Note: Video tutorials will refer to this as EasyState v3. The other tutorials are for older versions of Easy State. They may be helpful to fill in the gaps as the interface and workflow has changed but the core concepts are the same.</p>
</blockquote>

</body>
</html>
